{
    "collab_server" : "",
    "contents" : "### Final project Spring 2017\n### Jacy Hyde\n\n\n### This project will use classified landuse raster data and a\n### polygon shapefile to create an output dataframe with by-pixel\n### information about the location, year of deforestation, and \n### distance from the transmission line\n\ninstall.packages(\"raster\") #for reading, writing, analyzing, and modeling gridded spatial data\ninstall.packages(\"rgdal\") #read/write spatial objects, project data\ninstall.packages(\"sp\") #define data classes, some methods for visualizing, selecting, subsetting\ninstall.packages(\"rgeos\") #creates new geometries (buffers, distances, centroids, etc)\ninstall.packages(\"dplyr\") #data manipulation\ninstall.packages(\"rasterVis\") #data visualization for raster data\n\nlibrary(raster)\nlibrary(rgdal)\nlibrary(sp)\nlibrary(rgeos)\nlibrary(dplyr)\nlibrary(rasterVis)\n\n# Import transmission line using readOGR from rgdal\n# args: dsn= directory location, layer=layer name w/o extension\n# Make sure to have full component of shapefiles in your directory \nts_line <- readOGR(dsn = \".\", layer= \"NE_line1\")\n\n# Look at the file\nclass(ts_line)\n### [1] \"SpatialLinesDataFrame\"\n### attr(,\"package\")\n### [1] \"sp\"\n\nextent(ts_line)\n# class       : Extent \n# xmin        : -51.34025 \n# xmax        : -51.07553 \n# ymin        : 0.0277314 \n# ymax        : 0.8542698 \n\nsummary(ts_line)\n# Object of class SpatialLinesDataFrame\n\ncrs(ts_line)\n# CRS arguments:\n# +proj=longlat +datum=WGS84 +no_defs +ellps=WGS84 +towgs84=0,0,0 \n# THIS IS A GEOGRAPHIC COORDINATE SYSTEM: DOES NOT HAVE UNITS, USES THE 3D SPHERICAL SURFACE\n# TO DETERMINE WHERE YOU ARE ON EARTH RATHER THAN PROJECTING IT ONTO A 2D PLANE\n# CAN'T DO VERY MUCH ANALYSIS\n\n#plot the data\nplot(ts_line, col = \"red\", main = \"Transmission Line\")\n#dev.print(pdf, \"TransmissionLine.pdf\")\n# Save the plot as a pdf\n\n# Project to UTM zone 23S \n# The initial CRS had no reference units, so it can't be used to create a buffer\nline <- spTransform(ts_line, CRS(\"+init=epsg:29183\")) \n# spTransform projects a spatial object\n# the specified CRS code is the specific code for UTM23S\n\ncrs(line)\n# CRS arguments:\n#   +init=epsg:29183 +proj=utm +zone=23 +south +ellps=GRS67\n# +towgs84=-57,1,-41,0,0,0,0 +units=m +no_defs \n\n# @ is used to let you look at attribute data of the spatial object\nhead(ts_line@data)\n\n#create buffer\nbuffWidth <- 30000 #30km buffer\nlineBuff <- gBuffer(line, width = buffWidth, byid= FALSE)\n# gBuffer from rgeos\n# Expands the geometry of the pbject to include the area within a specified distance\n# Width is 30km\n# byid= FALSE treats the file as one object around which to buffer, rather than individual lines\n\n# can find the area of the buffer\n# Units are in meters so need to convert to km2\n# gArea from rgeos\narea <- gArea(lineBuff)/1E6\narea\n\n# convert CRS geographic corrdinate system so it can be used to clip the raster\nlineBuff <- spTransform(lineBuff, \"+proj=longlat +datum=WGS84 +no_defs +ellps=WGS84 +towgs84=0,0,0\" )\ncrs(lineBuff)\n#CRS arguments:\n#+proj=longlat +datum=WGS84 +ellps=WGS84 +towgs84=0,0,0 \n\n\n#plot the buffer and the lines\nplot(lineBuff, main = \"30 km buffer around transmission line\")\nlines(ts_line, col = \"green\")\n#dev.print(pdf, \"Buffer.pdf\")\n\n######################################################################\n# import raster\n# Make sure you have all the necessary files!\n# This raster shows year of deforestation for each pixel (1-14 = 2001-2014, 0 = still forest)\nHansen <- raster(\"./NE_HanAm.tif\")\n\n#view raster structure\nHansen\n# class       : RasterLayer \n# dimensions  : 61088, 40000, 2443520000  (nrow, ncol, ncell)\n# resolution  : 0.00025, 0.00025  (x, y)\n# extent      : -60, -50, -10, 5.272  (xmin, xmax, ymin, ymax)\n# coord. ref. : +proj=longlat +datum=WGS84 +no_defs +ellps=WGS84 +towgs84=0,0,0 \n# data source : /Users/JacyHyde/Desktop/GIS_Project_new/NE_HanAm.tif \n# names       : NE_HanAm \n# values      : 0, 14  (min, max)\n\n# Learn more exciting info about the raster\nhead(Hansen)\nplot(Hansen)\n#dev.print(pdf, \"Hansen.pdf\")\nmaxValue(Hansen)\n#[1] 14\nncell(Hansen)\n#[1] 2443520000\ncrs(Hansen)\n# CRS arguments:\n#   +proj=longlat +datum=WGS84 +no_defs +ellps=WGS84 +towgs84=0,0,0 \n\n#######################################################################\n#clip raster using the buffer\nextent(Hansen)\nHansen_clip <- crop(Hansen, extent(lineBuff), snap= \"out\")\n# Crop is from the raster package and returns a subset of an object as specified by \n# the extent- ie it only keeps the part of Hansen that overlaps with the buffer\n# snap- include pixels that are only part way in the buffer\n# does not conform to exact geometry\nplot(Hansen_clip, main = \"Result after applying crop\")\n\n# This function takes a while to run (~5min)\nbuf_raster <-rasterize(lineBuff, Hansen_clip)\n# Transfers values associated with the buffer into raster cells.\n# args are the input file and the raster \nplot(buf_raster, main = \"Result after applying rasterize\")\n\nHansen_buff <- mask(x=Hansen_clip, mask=buf_raster)\n# creates a new raster object that has the same values as X\n# except for the cells that are NA in a mask. These cells become NA. \n# args= x = the raster object\n# mask= the other raster object\n\nwriteRaster(Hansen_buff, \"hansen_buffer\", \"GTiff\", overwrite= TRUE)\n# save the raster as a GeoTiff file\n# overwrite = TRUE overwrites the file each time if I change it\n\n#plot with the ts line\nplot(Hansen_buff, main = \"30 km Buffer around Transmission Line\")\nlines(ts_line, col = \"red\")\n#dev.print(pdf, \"Buff_with_raster.pdf\")\n\n###########################################################################\n\n#reimport raster/buffer so I don't have to rerun the previous functions every time\n#Hansen_buff <- raster(\"./hansen_buffer.tif\")\n\n# Save the deforestation year and pixel ID as a dataframe\ndef_year_df <- as.data.frame(values(Hansen_buff))\nhead(def_year_df)\n\nlat <- as.data.frame(init(Hansen_buff, 'x'))\nlong <- as.data.frame(init(Hansen_buff, 'y'))\n# init creates a new raster layer with values reflecting a specified cell property, ie lat/long\n\n#######################################################################\n# Find the distance of the center of each pixel to the transmission line\n# Convert raster to points in order to use gDisatance to find distance values\nHansen_points <-  as(Hansen_clip,\"SpatialPoints\")\n# save it as a spatialPoints object\nstr(Hansen_points)\ncrs(Hansen_points)\n# CRS arguments:\n#   +proj=longlat +datum=WGS84 +no_defs +ellps=WGS84 +towgs84=0,0,0 \n\n#need to reproject again to give them units for the distance function\nHansen_points <- spTransform(Hansen_points, CRS(\"+init=epsg:29183\"))\n\ncrs(line)\n# CRS arguments:\n#   +init=epsg:29183 +proj=utm +zone=23 +south +ellps=GRS67\n# +towgs84=-57,1,-41,0,0,0,0 +units=m +no_defs \ncrs(Hansen_points)\n# CRS arguments:\n#   +init=epsg:29183 +proj=utm +zone=23 +south +ellps=GRS67\n# +towgs84=-57,1,-41,0,0,0,0 +units=m +no_defs \n\nclass(Hansen_points)\n\n#takes ~30min to run\ndist <-  gDistance(Hansen_points, line, byid=TRUE)\n\nclass(dist)\n#finds the distance from every point to all 28 lines. Inputs are the two files \n# and buid= true- finds distance to each line\n\ndim(dist)\n#[1]       28 17440572\n#there are 28 possible lines and 17440572 pixels - this found distance to EACH line\n\n#find the minimum distance between the a pixel and the nearest line- reduce it to one value\ndmin <- apply(dist, 2, min)\n#returns an array of values by applying the designated function to a matrix\n\n\nHansen_buff[] <- dmin\n#check to see if the values went into the raster\nvalues(Hansen_buff)\n\n\nplot(Hansen_buff, col= heat.colors(14), main = \"Raster of Pixel Distance from Transmission Line\")\nlines(ts_line, col = \"black\")\n#dev.print(pdf, \"Buff_distance.pdf\")\n\ndistance_df <- as.data.frame(values(Hansen_buff))\n#save the values from the distance raster in dataframe format\n\n################################################################\n#cleaning the data\n\n#bind two dataframes together\nfinal_df <- cbind(distance_df, def_year_df, lat, long)\n#cbind binds dataframes together\n\n##name columns\ncolnames(final_df) = c(\"distance(m)\", \"year_def\", \"Lat\", \"Long\")\nhead(final_df) #check\n\n#remove NA values-\nfinal_df <- na.omit(final_df)\n#remove 0s, also still forested. na.omit removes rows with NA values\nfinal_df <- filter(final_df, final_df[,2] != 0)\n#filter is from dplyr, allows you to select data based on values\n# [,2] (column 2) != is NOT EQUAL to 0\n\n#save CSV file\nwrite.csv(final_df, \"Results.csv\")\n\n#turn a csv into a spatial object\ncoordinates(final_df) <- ~Long+Lat #columns that correspond to the lat/long in the csv\nproj4string(final_df) = CRS(\"+proj=longlat +datum=WGS84\") #geogrpahic cooridnate system\n#don't use projected yet, becuase it needs to read using lat/long first. You can project after\nclass(final_df)\n\nplot(final_df)\n\n",
    "created" : 1491939147754.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2200254298",
    "id" : "9FC09115",
    "lastKnownWriteTime" : 1510695941,
    "last_content_update" : 1510695941577,
    "path" : "~/Documents/UF PhD Docs/Valle's Lab/RMeetUp_SpatialPres/Hyde_Final_script.R",
    "project_path" : "Hyde_Final_script.R",
    "properties" : {
    },
    "relative_order" : 2,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}